import{_ as n,c as s,a as i,o as a}from"./app-CJlkTddN.js";const t={};function l(c,e){return a(),s("div",null,e[0]||(e[0]=[i(`<h1 id="microservice-and-monolith-definition-switching-interface" tabindex="-1"><a class="header-anchor" href="#microservice-and-monolith-definition-switching-interface"><span>Microservice and Monolith Definition Switching Interface</span></a></h1><blockquote><p>The purpose of this document is to implement the automatic switching mechanism between the single interface and the microservice interface. Because SyncBoot officially supports the free switching between single and microservice by default, this mechanism is added. If you are completely developing microservices and do not consider free switching, you can ignore this article and go directly to <a href="https://help.jeecg.com/java/springcloud/dev/fengceng.html" target="_blank" rel="noopener noreferrer">#Practical Microservice Module Structure 2.4</a></p></blockquote><p>There is often such a scenario in microservices, where service A needs to call the method in service B. Then we can use openfeign to define the interface in service A and declare the method to remotely call the address exposed in service B (generally pointing to the method defined in the controller). Then when C, D, E... and more services appear, and these services may call service B, it is obviously unreasonable to let other services re-declare the interface for calling service B in their own code every time, so these interfaces need to be extracted and made into an independent interface module. For example, the interface of the system service that has been implemented in the project<br><img src="https://lfs.k.topthink.com/lfs/95c39bcc7e91778dbf9bcc6d2c11c0c66c9d932efd8f2ea9bd77f3c6e358c551.dat" alt=""></p><p>Notice:</p><ul><li>The names of interface projects should all end with -api</li><li>cloud-api means this is for cloud projects</li><li>local-api means it is used in a single unit</li><li>Declare two service interfaces to support switching between monolithic and microservices. You can decide which one to use based on your needs.</li></ul><h2 id="accomplish" tabindex="-1"><a class="header-anchor" href="#accomplish"><span>accomplish:</span></a></h2><p>1. Define the interface in loca-api (this project inherits CommonAPI. It is not necessary to customize a new interface if you do not need to use the methods in CommonAPI):</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">//单体</span>
<span class="line">public interface ISysBaseAPI extends CommonAPI {</span>
<span class="line">    LoginUser getUserById(String id);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>copy</p><p>2. Define the implementation class in the specific module. The corresponding system module here implements all methods corresponding to the interface in step 1.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">@Slf4j</span>
<span class="line">@Service</span>
<span class="line">public class SysBaseApiImpl implements ISysBaseAPI {</span>
<span class="line">    @Override</span>
<span class="line">	public LoginUser getUserById(String id) {</span>
<span class="line">		if(oConvertUtils.isEmpty(id)) {</span>
<span class="line">			return null;</span>
<span class="line">		}</span>
<span class="line">		LoginUser loginUser = new LoginUser();</span>
<span class="line">		SysUser sysUser = userMapper.selectById(id);</span>
<span class="line">		if(sysUser==null) {</span>
<span class="line">			return null;</span>
<span class="line">		}</span>
<span class="line">		BeanUtils.copyProperties(sysUser, loginUser);</span>
<span class="line">		return loginUser;</span>
<span class="line">	}</span>
<span class="line"></span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>copy</p><p>3. Define the interface in cloud-api, the FeignClient annotation value is the service name to be called, and the method annotation GetMapping points to the request interface defined in system</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">//微服务</span>
<span class="line">@Component</span>
<span class="line">@FeignClient(contextId = &quot;sysBaseRemoteApi&quot;, value = ServiceNameConstants.SYSTEM_SERVICE, fallbackFactory = SysBaseAPIFallbackFactory.class)</span>
<span class="line">public interface ISysBaseAPI extends CommonAPI {</span>
<span class="line">    @GetMapping(&quot;/sys/api/getUserById&quot;)</span>
<span class="line">    LoginUser getUserById(@RequestParam(&quot;id&quot;) String id);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>copy</p><p>4. Define the controller in the specific module. The corresponding system module here is used to call the microservice interface</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">@RestController</span>
<span class="line">@RequestMapping(&quot;/sys/api&quot;)</span>
<span class="line">public class SystemAPIController {</span>
<span class="line"></span>
<span class="line">    @Autowired</span>
<span class="line">    private ISysBaseAPI sysBaseAPI;</span>
<span class="line"></span>
<span class="line">    @GetMapping(&quot;/getUserById&quot;)</span>
<span class="line">    LoginUser getUserById(@RequestParam(&quot;id&quot;) String id){</span>
<span class="line">        return sysBaseAPI.getUserById(id);</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>copy</p><p><strong>Notice</strong> :</p><ul><li>The interface injected into this controller is the singleton interface declared in step 1.</li><li>The method request address should be consistent with the GetMapping of the microservice interface method in step 3.</li></ul><h4 id="at-this-point-both-single-and-microservices-can-call-the-api-under-the-system" tabindex="-1"><a class="header-anchor" href="#at-this-point-both-single-and-microservices-can-call-the-api-under-the-system"><span><em>At this point, both single and microservices can call the API under the system</em></span></a></h4><hr><h2 id="use" tabindex="-1"><a class="header-anchor" href="#use"><span>use:</span></a></h2><p>Add dependencies to pom in a single file:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">&lt;dependency&gt;</span>
<span class="line">    &lt;groupId&gt;org.jeecgframework.boot&lt;/groupId&gt;</span>
<span class="line">    &lt;artifactId&gt;jeecg-system-local-api&lt;/artifactId&gt;</span>
<span class="line">&lt;/dependency&gt;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>copy</p><p>Microservices add dependencies in pom</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">&lt;dependency&gt;</span>
<span class="line">    &lt;groupId&gt;org.jeecgframework.boot&lt;/groupId&gt;</span>
<span class="line">    &lt;artifactId&gt;jeecg-system-cloud-api&lt;/artifactId&gt;</span>
<span class="line">&lt;/dependency&gt;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>copy</p><h2 id="summarize" tabindex="-1"><a class="header-anchor" href="#summarize"><span>Summarize:</span></a></h2><p>The above description is about the implementation and use of the system module API. If you need to write an API for your own new module, you can refer to its rules.<br> 1. Add two new API projects<br> 2. Name them ending with local-api/cloud-api<br> 3. Define interfaces in the two projects respectively<br> 4. Define implementation classes in your own modules to implement the interfaces in local-api<br> 5. Define controllers in your own modules, inject the interfaces in local-api, and keep the method request addresses consistent with cloud-api<br> 6. For other module calls, you only need to switch specific dependencies according to the needs of single or microservices.</p>`,31)]))}const d=n(t,[["render",l]]),o=JSON.parse('{"path":"/syncboot/microservice/practical-skills/microservice-and-monolith-definition-switching-interface.html","title":"Microservice and Monolith Definition Switching Interface","lang":"ko-KR","frontmatter":{"order":9},"git":{"updatedTime":1749179241000,"contributors":[{"name":"poh","username":"poh","email":"poh@empasy.com","commits":1,"url":"https://github.com/poh"}],"changelog":[{"hash":"a96cbbf1f6c96d0e9d6bafa4174131f10429b849","time":1749179241000,"email":"poh@empasy.com","author":"poh","message":"sync 제품군 추가"}]},"filePathRelative":"syncboot/microservice/practical-skills/microservice-and-monolith-definition-switching-interface.md"}');export{d as comp,o as data};
